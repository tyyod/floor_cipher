{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Floor \u00b6 Floor provides a neat SQLite abstraction for your Flutter applications inspired by the Room persistence library . It comes with automatic mapping between in-memory objects and database rows while still offering full control of the database with the use of SQL. As a consequence, it's necessary to have an understanding of SQL and SQLite in order to harvest Floor's full potential. null-safe typesafe reactive lightweight SQL centric no hidden magic no hidden costs iOS, Android, Linux, macOS, Windows Important The library is open to contributions! Refer to GitHub Discussions for questions, ideas, and discussions.","title":"Welcome"},{"location":"#welcome-to-floor","text":"Floor provides a neat SQLite abstraction for your Flutter applications inspired by the Room persistence library . It comes with automatic mapping between in-memory objects and database rows while still offering full control of the database with the use of SQL. As a consequence, it's necessary to have an understanding of SQL and SQLite in order to harvest Floor's full potential. null-safe typesafe reactive lightweight SQL centric no hidden magic no hidden costs iOS, Android, Linux, macOS, Windows Important The library is open to contributions! Refer to GitHub Discussions for questions, ideas, and discussions.","title":"Welcome to Floor"},{"location":"architecture/","text":"Architecture \u00b6 The components for storing and accessing data are Entity , Data Access Object (DAO) and Database . The first, Entity, represents a persistent class and thus a database table. DAOs manage the access to Entities and take care of the mapping between in-memory objects and table rows. Lastly, Database, is the central access point to the underlying SQLite database. It holds the DAOs and, beyond that, takes care of initializing the database and its schema. Room serves as the source of inspiration for this composition, because it allows creating a clean separation of the component's responsibilities. The figure shows the relationship between Entity, DAO and Database.","title":"Architecture"},{"location":"architecture/#architecture","text":"The components for storing and accessing data are Entity , Data Access Object (DAO) and Database . The first, Entity, represents a persistent class and thus a database table. DAOs manage the access to Entities and take care of the mapping between in-memory objects and table rows. Lastly, Database, is the central access point to the underlying SQLite database. It holds the DAOs and, beyond that, takes care of initializing the database and its schema. Room serves as the source of inspiration for this composition, because it allows creating a clean separation of the component's responsibilities. The figure shows the relationship between Entity, DAO and Database.","title":"Architecture"},{"location":"changelog/","text":"Changelog \u00b6 1.2.0 \u00b6 Changes \u00b6 Improve escaping by using library \ud83d\udc1b Bug Fixes \u00b6 Bugfix/nullable transaction return \ud83d\udee0 Maintenance \u00b6 Update dependencies 1.1.0 \u00b6 All credits for this release go to mqus. Changes \u00b6 Update deps Increase test coverage Bump locked floor_generator version to 1.0.1 \ud83d\ude80 Features \u00b6 Add onConfigure callback \ud83d\udc1b Bug Fixes \u00b6 Retain index ordering 1.0.1 \u00b6 Changes \u00b6 Bump mockito to 5.0.3 Update dependencies to null-safe versions \ud83d\ude80 Features \u00b6 Improved Parameter mapping for query methods 1.0.0 \u00b6 Changes \u00b6 Use stable Dart 2.12.0 \ud83d\ude80 Features \u00b6 Make floor null-safe 0.19.1 \u00b6 Changes \u00b6 Remove floor example to pass static analysis 0.19.0 \u00b6 Changes \u00b6 Update website theme Update license with all authors Fix getting started syntax highlighting Improve FTS documentation Introduce tab navigation to website Fix typo in doc title Improve website Slim down README Create MkDocs website Add isolates section to README Run CI only on pushes to develop Use GitHub Discussions for ideas and feedback Add example to floor package \ud83d\ude80 Features \u00b6 Add Full-text Search support \ud83d\udc1b Bug Fixes \u00b6 Fix desktop database path retrieval 0.18.0 \u00b6 Documentation update on DateTimeConverter sample Change ForeignKeyAction to enum in the generator Add primary key auto increment test \ud83d\ude80 Features \u00b6 Add support for WITH statements for DatabaseViews \ud83d\udc1b Bug Fixes \u00b6 More tolerant query with list parameter parsing 0.17.0 \u00b6 \ud83d\udc1b Bug Fixes \u00b6 Generate distinct type converter instances Fix generation of DAO method with list argument using type converters 0.16.0 \u00b6 \ud83d\ude80 Features \u00b6 Add experimental support for type converters 0.15.0 \u00b6 Changes \u00b6 Update dependencies \ud83d\ude80 Features \u00b6 Add support for WITHOUT ROWID tables Check transaction method return types and allow non-void returns 0.14.0 \u00b6 Changes \u00b6 Document entity inheritance and add integration test Raise minimum sqflite version to 1.3.0 add integration test for transaction rollback Mention missing null propagation in streams Fix types (integer instead of real) 0.13.0 \u00b6 Attention Breaking Change \u00b6 Apply camel case to constants You need to migrate the explicit usages of OnConflictStrategy and ForeignKeyAction from snake case to camel case. Changes \u00b6 Mention SQL centricity of Floor in README Add banner to README Update the description of the library Migrate OnConflictStrategy to enum Add more precise limitations of entity class and streams to README Add DAO inheritance example to README Fix database and DAO usage example in the README Update README.md Assert example app's behavior Mention that floor uses first constructor found in entity class Remove snapshot version instructions from README \ud83d\ude80 Features \u00b6 Support Linux, macOS, Windows Implement simple Streams on DatabaseViews, fix multi-dao changelistener \ud83d\udc1b Bug Fixes \u00b6 Await database path retrieval Fix boolean conversion issues, add regression test, fix indentation Fix wrongly parsed arguments in @Query 0.12.0 \u00b6 Changes \u00b6 Ignore Getters&Setters Use Flutter bundled pub to get and upgrade project dependencies Generate database implementation on every CI run Throw exception when querying for unsupported type Add generated code for example app Add workflow scripts Run real database tests on development machine and CI \ud83d\ude80 Features \u00b6 Support ByteArrays/Blobs Support inherited fields for entities and views Support database views Support inherited DAO methods Support asynchronous migrations \ud83d\udc1b Bug Fixes \u00b6 Fix failing SQLite installation process on CI Fix failing stream query test 0.11.0 \u00b6 Changes \u00b6 Refactor string utility function into extension function Refactor annotation check functions to use extension functions Refactor type check functions to use extension functions \ud83d\ude80 Features \u00b6 Ignore fields of entities by adding ignore annotation Handle named constructor parameters and ignore field order Exclude static fields from entity mapping 0.10.0 \u00b6 Changes \u00b6 Update dependencies Update README with correct instructions to initialize in memory database \ud83d\udc1b Bug Fixes \u00b6 Make in-memory database actually be just in memory 0.9.0 \u00b6 \ud83d\udc1b Bug Fixes \u00b6 Make IN clauses work with strings Fix foreign key action string representation 0.8.0 \u00b6 Changes \u00b6 Update README with clear package import instructions \ud83d\ude80 Features \u00b6 Introduce static 'to map' functions Add optional callback functions when opening database \ud83d\udc1b Bug Fixes \u00b6 Allow int and string (composite) primary keys 0.7.0 \u00b6 \ud83d\udc1b Bug Fixes \u00b6 Retain reactivity when using transactions 0.6.0 \u00b6 \ud83d\ude80 Features \u00b6 Add support for IN clauses in query statements Enable compound primary keys 0.5.0 \u00b6 Changes \u00b6 Make tasks deletable in example app \ud83d\ude80 Features \u00b6 Allow multiline string queries Allow void-return queries with arguments 0.4.2 \u00b6 \ud83d\udc1b Bug Fixes \u00b6 Fix query parameter substitution regex 0.4.0 \u00b6 Changes \u00b6 Enable coverage report Simplify type assertions and add tests \ud83d\ude80 Features \u00b6 Allow more convenient database initialization \ud83d\udc1b Bug Fixes \u00b6 Use query argument binding instead of manual binding 0.3.0 \u00b6 Changes \u00b6 Use TypeChecker for all annotations Add publishing instructions Remove unused annotation names Simplify the mapping from an entity to a map Fix database writer test Make stream emit query result on subscription Update example to use StreamBuilder Update README \ud83d\udc1b Bug Fixes \u00b6 Correct mapper instance name referenced by generated query methods Fix adapter instances naming 0.2.0 \u00b6 Changes \u00b6 Add database adapters Run floor Flutter tests Move value objects to value_objects directory Map source elements into value objects in processors Use GeneratorForAnnotation and TypeChecker to verify annotations Throw more specific errors on obfuscated database annotation \ud83d\ude80 Features \u00b6 Add support for migrations Add support for returning Streams as query result Support accessing data from Data Access Objects Add entity classes to database annotation Add support for indices 0.1.0 \u00b6 \ud83d\ude80 Features \u00b6 Support conflict strategies when inserting and updating records Add support for running queries that return void Add support for foreign keys Add parameter verification for query methods Return deleted row count on delete Return updated rows count on update Return ID/s of inserted item/s Add support for transactions Add support for changing (insert, update, delete) lists Support custom entity name Enable NOT NULL columns Enable custom column name mapping Add delete methods code generation and fix update methods Add update methods code generation Add insert methods code generation Add code generator for query methods Code generation for database creation","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#120","text":"","title":"1.2.0"},{"location":"changelog/#changes","text":"Improve escaping by using library","title":"Changes"},{"location":"changelog/#bug-fixes","text":"Bugfix/nullable transaction return","title":"\ud83d\udc1b Bug Fixes"},{"location":"changelog/#maintenance","text":"Update dependencies","title":"\ud83d\udee0 Maintenance"},{"location":"changelog/#110","text":"All credits for this release go to mqus.","title":"1.1.0"},{"location":"changelog/#changes_1","text":"Update deps Increase test coverage Bump locked floor_generator version to 1.0.1","title":"Changes"},{"location":"changelog/#features","text":"Add onConfigure callback","title":"\ud83d\ude80 Features"},{"location":"changelog/#bug-fixes_1","text":"Retain index ordering","title":"\ud83d\udc1b Bug Fixes"},{"location":"changelog/#101","text":"","title":"1.0.1"},{"location":"changelog/#changes_2","text":"Bump mockito to 5.0.3 Update dependencies to null-safe versions","title":"Changes"},{"location":"changelog/#features_1","text":"Improved Parameter mapping for query methods","title":"\ud83d\ude80 Features"},{"location":"changelog/#100","text":"","title":"1.0.0"},{"location":"changelog/#changes_3","text":"Use stable Dart 2.12.0","title":"Changes"},{"location":"changelog/#features_2","text":"Make floor null-safe","title":"\ud83d\ude80 Features"},{"location":"changelog/#0191","text":"","title":"0.19.1"},{"location":"changelog/#changes_4","text":"Remove floor example to pass static analysis","title":"Changes"},{"location":"changelog/#0190","text":"","title":"0.19.0"},{"location":"changelog/#changes_5","text":"Update website theme Update license with all authors Fix getting started syntax highlighting Improve FTS documentation Introduce tab navigation to website Fix typo in doc title Improve website Slim down README Create MkDocs website Add isolates section to README Run CI only on pushes to develop Use GitHub Discussions for ideas and feedback Add example to floor package","title":"Changes"},{"location":"changelog/#features_3","text":"Add Full-text Search support","title":"\ud83d\ude80 Features"},{"location":"changelog/#bug-fixes_2","text":"Fix desktop database path retrieval","title":"\ud83d\udc1b Bug Fixes"},{"location":"changelog/#0180","text":"Documentation update on DateTimeConverter sample Change ForeignKeyAction to enum in the generator Add primary key auto increment test","title":"0.18.0"},{"location":"changelog/#features_4","text":"Add support for WITH statements for DatabaseViews","title":"\ud83d\ude80 Features"},{"location":"changelog/#bug-fixes_3","text":"More tolerant query with list parameter parsing","title":"\ud83d\udc1b Bug Fixes"},{"location":"changelog/#0170","text":"","title":"0.17.0"},{"location":"changelog/#bug-fixes_4","text":"Generate distinct type converter instances Fix generation of DAO method with list argument using type converters","title":"\ud83d\udc1b Bug Fixes"},{"location":"changelog/#0160","text":"","title":"0.16.0"},{"location":"changelog/#features_5","text":"Add experimental support for type converters","title":"\ud83d\ude80 Features"},{"location":"changelog/#0150","text":"","title":"0.15.0"},{"location":"changelog/#changes_6","text":"Update dependencies","title":"Changes"},{"location":"changelog/#features_6","text":"Add support for WITHOUT ROWID tables Check transaction method return types and allow non-void returns","title":"\ud83d\ude80 Features"},{"location":"changelog/#0140","text":"","title":"0.14.0"},{"location":"changelog/#changes_7","text":"Document entity inheritance and add integration test Raise minimum sqflite version to 1.3.0 add integration test for transaction rollback Mention missing null propagation in streams Fix types (integer instead of real)","title":"Changes"},{"location":"changelog/#0130","text":"Attention","title":"0.13.0"},{"location":"changelog/#breaking-change","text":"Apply camel case to constants You need to migrate the explicit usages of OnConflictStrategy and ForeignKeyAction from snake case to camel case.","title":"Breaking Change"},{"location":"changelog/#changes_8","text":"Mention SQL centricity of Floor in README Add banner to README Update the description of the library Migrate OnConflictStrategy to enum Add more precise limitations of entity class and streams to README Add DAO inheritance example to README Fix database and DAO usage example in the README Update README.md Assert example app's behavior Mention that floor uses first constructor found in entity class Remove snapshot version instructions from README","title":"Changes"},{"location":"changelog/#features_7","text":"Support Linux, macOS, Windows Implement simple Streams on DatabaseViews, fix multi-dao changelistener","title":"\ud83d\ude80 Features"},{"location":"changelog/#bug-fixes_5","text":"Await database path retrieval Fix boolean conversion issues, add regression test, fix indentation Fix wrongly parsed arguments in @Query","title":"\ud83d\udc1b Bug Fixes"},{"location":"changelog/#0120","text":"","title":"0.12.0"},{"location":"changelog/#changes_9","text":"Ignore Getters&Setters Use Flutter bundled pub to get and upgrade project dependencies Generate database implementation on every CI run Throw exception when querying for unsupported type Add generated code for example app Add workflow scripts Run real database tests on development machine and CI","title":"Changes"},{"location":"changelog/#features_8","text":"Support ByteArrays/Blobs Support inherited fields for entities and views Support database views Support inherited DAO methods Support asynchronous migrations","title":"\ud83d\ude80 Features"},{"location":"changelog/#bug-fixes_6","text":"Fix failing SQLite installation process on CI Fix failing stream query test","title":"\ud83d\udc1b Bug Fixes"},{"location":"changelog/#0110","text":"","title":"0.11.0"},{"location":"changelog/#changes_10","text":"Refactor string utility function into extension function Refactor annotation check functions to use extension functions Refactor type check functions to use extension functions","title":"Changes"},{"location":"changelog/#features_9","text":"Ignore fields of entities by adding ignore annotation Handle named constructor parameters and ignore field order Exclude static fields from entity mapping","title":"\ud83d\ude80 Features"},{"location":"changelog/#0100","text":"","title":"0.10.0"},{"location":"changelog/#changes_11","text":"Update dependencies Update README with correct instructions to initialize in memory database","title":"Changes"},{"location":"changelog/#bug-fixes_7","text":"Make in-memory database actually be just in memory","title":"\ud83d\udc1b Bug Fixes"},{"location":"changelog/#090","text":"","title":"0.9.0"},{"location":"changelog/#bug-fixes_8","text":"Make IN clauses work with strings Fix foreign key action string representation","title":"\ud83d\udc1b Bug Fixes"},{"location":"changelog/#080","text":"","title":"0.8.0"},{"location":"changelog/#changes_12","text":"Update README with clear package import instructions","title":"Changes"},{"location":"changelog/#features_10","text":"Introduce static 'to map' functions Add optional callback functions when opening database","title":"\ud83d\ude80 Features"},{"location":"changelog/#bug-fixes_9","text":"Allow int and string (composite) primary keys","title":"\ud83d\udc1b Bug Fixes"},{"location":"changelog/#070","text":"","title":"0.7.0"},{"location":"changelog/#bug-fixes_10","text":"Retain reactivity when using transactions","title":"\ud83d\udc1b Bug Fixes"},{"location":"changelog/#060","text":"","title":"0.6.0"},{"location":"changelog/#features_11","text":"Add support for IN clauses in query statements Enable compound primary keys","title":"\ud83d\ude80 Features"},{"location":"changelog/#050","text":"","title":"0.5.0"},{"location":"changelog/#changes_13","text":"Make tasks deletable in example app","title":"Changes"},{"location":"changelog/#features_12","text":"Allow multiline string queries Allow void-return queries with arguments","title":"\ud83d\ude80 Features"},{"location":"changelog/#042","text":"","title":"0.4.2"},{"location":"changelog/#bug-fixes_11","text":"Fix query parameter substitution regex","title":"\ud83d\udc1b Bug Fixes"},{"location":"changelog/#040","text":"","title":"0.4.0"},{"location":"changelog/#changes_14","text":"Enable coverage report Simplify type assertions and add tests","title":"Changes"},{"location":"changelog/#features_13","text":"Allow more convenient database initialization","title":"\ud83d\ude80 Features"},{"location":"changelog/#bug-fixes_12","text":"Use query argument binding instead of manual binding","title":"\ud83d\udc1b Bug Fixes"},{"location":"changelog/#030","text":"","title":"0.3.0"},{"location":"changelog/#changes_15","text":"Use TypeChecker for all annotations Add publishing instructions Remove unused annotation names Simplify the mapping from an entity to a map Fix database writer test Make stream emit query result on subscription Update example to use StreamBuilder Update README","title":"Changes"},{"location":"changelog/#bug-fixes_13","text":"Correct mapper instance name referenced by generated query methods Fix adapter instances naming","title":"\ud83d\udc1b Bug Fixes"},{"location":"changelog/#020","text":"","title":"0.2.0"},{"location":"changelog/#changes_16","text":"Add database adapters Run floor Flutter tests Move value objects to value_objects directory Map source elements into value objects in processors Use GeneratorForAnnotation and TypeChecker to verify annotations Throw more specific errors on obfuscated database annotation","title":"Changes"},{"location":"changelog/#features_14","text":"Add support for migrations Add support for returning Streams as query result Support accessing data from Data Access Objects Add entity classes to database annotation Add support for indices","title":"\ud83d\ude80 Features"},{"location":"changelog/#010","text":"","title":"0.1.0"},{"location":"changelog/#features_15","text":"Support conflict strategies when inserting and updating records Add support for running queries that return void Add support for foreign keys Add parameter verification for query methods Return deleted row count on delete Return updated rows count on update Return ID/s of inserted item/s Add support for transactions Add support for changing (insert, update, delete) lists Support custom entity name Enable NOT NULL columns Enable custom column name mapping Add delete methods code generation and fix update methods Add update methods code generation Add insert methods code generation Add code generator for query methods Code generation for database creation","title":"\ud83d\ude80 Features"},{"location":"daos/","text":"Data Access Objects \u00b6 These components are responsible for managing access to the underlying SQLite database and are defined as abstract classes with method signatures and query statements. DAO classes can use inherited methods by implementing and extending classes while also using mixins. @dao abstract class PersonDao { @Query ( 'SELECT * FROM Person' ) Future < List < Person >> findAllPersons (); @Query ( 'SELECT * FROM Person WHERE id = :id' ) Stream < Person ?> findPersonById ( int id ); @insert Future < void > insertPerson ( Person person ); } Queries \u00b6 Method signatures turn into query methods by adding the @Query() annotation with the query in parenthesis to them. Be mindful about the correctness of your SQL statements as they are only partly validated while generating the code. These queries have to return either a Future or a Stream of an entity or void . Returning Future<void> comes in handy whenever you want to delete the full content of a table, for instance. Some query method examples can be seen in the following. A function returning a single item will return null when no matching row is found. Thereby, the function is required to return a nullable type. For example Person? . This way, we leave the handling of an absent row up to you and don't attempt to guess intention. @Query ( 'SELECT * FROM Person WHERE id = :id' ) Future < Person ?> findPersonById ( int id ); @Query ( 'SELECT * FROM Person WHERE id = :id AND name = :name' ) Future < Person ?> findPersonByIdAndName ( int id , String name ); @Query ( 'SELECT * FROM Person' ) Future < List < Person >> findAllPersons (); // select multiple items @Query ( 'SELECT * FROM Person' ) Stream < List < Person >> findAllPersonsAsStream (); // stream return @Query ( 'DELETE FROM Person' ) Future < void > deleteAllPersons (); // query without returning an entity @Query ( 'SELECT * FROM Person WHERE id IN (:ids)' ) Future < List < Person >> findPersonsWithIds ( List < int > ids ); // query with IN clause Query arguments, when using SQLite's LIKE operator, have to be supplied by the input of a method. It's not possible to define a pattern matching argument like %foo% in the query itself. // dao @Query ( 'SELECT * FROM Person WHERE name LIKE :name' ) Future < List < Person >> findPersonsWithNamesLike ( String name ); // usage final name = '%foo%' ; await dao . findPersonsWithNamesLike ( name ); Data Changes \u00b6 Use the @insert , @update and @delete annotations for inserting and changing persistent data. All these methods accept single or multiple entity instances. Insert \u00b6 @insert marks a method as an insertion method. When using the capitalized @Insert you can specify a conflict strategy. Else it just defaults to aborting the insert. These methods can return a Future of either void , int or List<int> . - void return nothing - int return primary key of inserted item - List<int> return primary keys of inserted items @Insert ( onConflict: OnConflictStrategy . rollback ) Future < void > insertPerson ( Person person ); @insert Future < List < int >> insertPersons ( List < Person > persons ); Update \u00b6 @update marks a method as an update method. When using the capitalized @Update you can specify a conflict strategy. Else it just defaults to aborting the update. These methods can return a Future of either void or int . - void return nothing - int return number of changed rows @Update ( onConflict: OnConflictStrategy . replace ) Future < void > updatePerson ( Person person ); @update Future < int > updatePersons ( List < Person > persons ); Delete \u00b6 @delete marks a method as a deletion method. These methods can return a Future of either void or int . - void return nothing - int return number of deleted rows @delete Future < void > deletePerson ( Person person ); @delete Future < int > deletePersons ( List < Person > persons ); Streams \u00b6 As already mentioned, queries cannot only return values once when called but also continuous streams of query results. The returned streams keep you in sync with the changes happening in the database tables. This feature plays well with the StreamBuilder widget which accepts a stream of values and rebuilds itself whenever there is a new emission. These methods return broadcast streams and thus, can have multiple listeners. A function returning a stream of single items will emit null when no matching row is found. Thereby, it's necessary to make the function return a stream of a nullable type. For example Stream<Person?> . In case you're not interested in null s, you can simply use Stream.where((value) => value != null) to get rid of them. // definition @dao abstract class PersonDao { @Query ( 'SELECT * FROM Person WHERE id = :id' ) Stream < Person ?> findPersonByIdAsStream ( int id ); @Query ( 'SELECT * FROM Person' ) Stream < List < Person >> findAllPersonsAsStream (); } // usage StreamBuilder < List < Person >> ( stream: dao . findAllPersonsAsStream (), builder: ( BuildContext context , AsyncSnapshot < List < Person >> snapshot ) { // do something with the values here }, ); Attention Only methods annotated with @insert , @update and @delete trigger Stream emissions. Inserting data by using the @Query() annotation doesn't. It is now possible to return a Stream if the function queries a database view. But it will fire on any @update , @insert , @delete events in the whole database, which can get quite taxing on the runtime. Please add it only if you know what you are doing! This is mostly due to the complexity of detecting which entities are involved in a database view. Transactions \u00b6 Whenever you want to perform some operations in a transaction you have to add the @transaction annotation to the method. It's also required to add the async modifier. These methods have to return a Future . @transaction Future < void > replacePersons ( List < Person > persons ) async { await deleteAllPersons (); await insertPersons ( persons ); } Inheritance \u00b6 Data access object classes support inheritance as shown in the following. There is no limit to inheritance levels and thus, each abstract parent can have another abstract parent. Bear in mind that only abstract classes allow method signatures without an implementation body and thereby, make sure to position your to-be-inherited methods in an abstract class and extend this class with your DAO. @dao abstract class PersonDao extends AbstractDao < Person > { @Query ( 'SELECT * FROM Person WHERE id = :id' ) Future < Person ?> findPersonById ( int id ); } abstract class AbstractDao < T > { @insert Future < void > insertItem ( T item ); } // usage final person = Person ( 1 , 'Simon' ); await personDao . insertItem ( person ); final result = await personDao . findPersonById ( 1 );","title":"Data Access Objects"},{"location":"daos/#data-access-objects","text":"These components are responsible for managing access to the underlying SQLite database and are defined as abstract classes with method signatures and query statements. DAO classes can use inherited methods by implementing and extending classes while also using mixins. @dao abstract class PersonDao { @Query ( 'SELECT * FROM Person' ) Future < List < Person >> findAllPersons (); @Query ( 'SELECT * FROM Person WHERE id = :id' ) Stream < Person ?> findPersonById ( int id ); @insert Future < void > insertPerson ( Person person ); }","title":"Data Access Objects"},{"location":"daos/#queries","text":"Method signatures turn into query methods by adding the @Query() annotation with the query in parenthesis to them. Be mindful about the correctness of your SQL statements as they are only partly validated while generating the code. These queries have to return either a Future or a Stream of an entity or void . Returning Future<void> comes in handy whenever you want to delete the full content of a table, for instance. Some query method examples can be seen in the following. A function returning a single item will return null when no matching row is found. Thereby, the function is required to return a nullable type. For example Person? . This way, we leave the handling of an absent row up to you and don't attempt to guess intention. @Query ( 'SELECT * FROM Person WHERE id = :id' ) Future < Person ?> findPersonById ( int id ); @Query ( 'SELECT * FROM Person WHERE id = :id AND name = :name' ) Future < Person ?> findPersonByIdAndName ( int id , String name ); @Query ( 'SELECT * FROM Person' ) Future < List < Person >> findAllPersons (); // select multiple items @Query ( 'SELECT * FROM Person' ) Stream < List < Person >> findAllPersonsAsStream (); // stream return @Query ( 'DELETE FROM Person' ) Future < void > deleteAllPersons (); // query without returning an entity @Query ( 'SELECT * FROM Person WHERE id IN (:ids)' ) Future < List < Person >> findPersonsWithIds ( List < int > ids ); // query with IN clause Query arguments, when using SQLite's LIKE operator, have to be supplied by the input of a method. It's not possible to define a pattern matching argument like %foo% in the query itself. // dao @Query ( 'SELECT * FROM Person WHERE name LIKE :name' ) Future < List < Person >> findPersonsWithNamesLike ( String name ); // usage final name = '%foo%' ; await dao . findPersonsWithNamesLike ( name );","title":"Queries"},{"location":"daos/#data-changes","text":"Use the @insert , @update and @delete annotations for inserting and changing persistent data. All these methods accept single or multiple entity instances.","title":"Data Changes"},{"location":"daos/#insert","text":"@insert marks a method as an insertion method. When using the capitalized @Insert you can specify a conflict strategy. Else it just defaults to aborting the insert. These methods can return a Future of either void , int or List<int> . - void return nothing - int return primary key of inserted item - List<int> return primary keys of inserted items @Insert ( onConflict: OnConflictStrategy . rollback ) Future < void > insertPerson ( Person person ); @insert Future < List < int >> insertPersons ( List < Person > persons );","title":"Insert"},{"location":"daos/#update","text":"@update marks a method as an update method. When using the capitalized @Update you can specify a conflict strategy. Else it just defaults to aborting the update. These methods can return a Future of either void or int . - void return nothing - int return number of changed rows @Update ( onConflict: OnConflictStrategy . replace ) Future < void > updatePerson ( Person person ); @update Future < int > updatePersons ( List < Person > persons );","title":"Update"},{"location":"daos/#delete","text":"@delete marks a method as a deletion method. These methods can return a Future of either void or int . - void return nothing - int return number of deleted rows @delete Future < void > deletePerson ( Person person ); @delete Future < int > deletePersons ( List < Person > persons );","title":"Delete"},{"location":"daos/#streams","text":"As already mentioned, queries cannot only return values once when called but also continuous streams of query results. The returned streams keep you in sync with the changes happening in the database tables. This feature plays well with the StreamBuilder widget which accepts a stream of values and rebuilds itself whenever there is a new emission. These methods return broadcast streams and thus, can have multiple listeners. A function returning a stream of single items will emit null when no matching row is found. Thereby, it's necessary to make the function return a stream of a nullable type. For example Stream<Person?> . In case you're not interested in null s, you can simply use Stream.where((value) => value != null) to get rid of them. // definition @dao abstract class PersonDao { @Query ( 'SELECT * FROM Person WHERE id = :id' ) Stream < Person ?> findPersonByIdAsStream ( int id ); @Query ( 'SELECT * FROM Person' ) Stream < List < Person >> findAllPersonsAsStream (); } // usage StreamBuilder < List < Person >> ( stream: dao . findAllPersonsAsStream (), builder: ( BuildContext context , AsyncSnapshot < List < Person >> snapshot ) { // do something with the values here }, ); Attention Only methods annotated with @insert , @update and @delete trigger Stream emissions. Inserting data by using the @Query() annotation doesn't. It is now possible to return a Stream if the function queries a database view. But it will fire on any @update , @insert , @delete events in the whole database, which can get quite taxing on the runtime. Please add it only if you know what you are doing! This is mostly due to the complexity of detecting which entities are involved in a database view.","title":"Streams"},{"location":"daos/#transactions","text":"Whenever you want to perform some operations in a transaction you have to add the @transaction annotation to the method. It's also required to add the async modifier. These methods have to return a Future . @transaction Future < void > replacePersons ( List < Person > persons ) async { await deleteAllPersons (); await insertPersons ( persons ); }","title":"Transactions"},{"location":"daos/#inheritance","text":"Data access object classes support inheritance as shown in the following. There is no limit to inheritance levels and thus, each abstract parent can have another abstract parent. Bear in mind that only abstract classes allow method signatures without an implementation body and thereby, make sure to position your to-be-inherited methods in an abstract class and extend this class with your DAO. @dao abstract class PersonDao extends AbstractDao < Person > { @Query ( 'SELECT * FROM Person WHERE id = :id' ) Future < Person ?> findPersonById ( int id ); } abstract class AbstractDao < T > { @insert Future < void > insertItem ( T item ); } // usage final person = Person ( 1 , 'Simon' ); await personDao . insertItem ( person ); final result = await personDao . findPersonById ( 1 );","title":"Inheritance"},{"location":"database-views/","text":"Database Views \u00b6 If you want to define static SELECT -statements which return different types than your entities, your best option is to use @DatabaseView . A database view can be understood as a virtual table, which can be queried like a real table. A database view in floor is defined and used similarly to entities, with the main difference being that access is read-only, which means that update, insert and delete functions are not possible. Similarly to entities, the class name is used if no viewName was set. @DatabaseView ( 'SELECT distinct(name) AS name FROM person' , viewName: 'name' ) class Name { final String name ; Name ( this . name ); } Database views do not have any foreign/primary keys or indices. Instead, you should manually define indices which fit to your statement and put them into the @Entity annotation of the involved entities. Setters, getters and static fields are automatically ignored (like in entities), you can specify additional fields to ignore by annotating them with @ignore . After defining a database view in your code, you have to add it to your database by adding it to the views field of the @Database annotation: @Database ( version: 1 , entities: [ Person ], views: [ Name ]) abstract class AppDatabase extends FloorDatabase { // DAO getters } You can then query the view via a DAO function like an entity. It is possible for DatabaseViews to inherit common fields from a base class, just like in entities. Attention It is now possible to return a Stream object from a DAO method which queries a database view. But it will fire on any @update , @insert , @delete events in the whole database, which can get quite taxing on the runtime. Please add it only if you know what you are doing! This is mostly due to the complexity of detecting which entities are involved in a database view.","title":"Database Views"},{"location":"database-views/#database-views","text":"If you want to define static SELECT -statements which return different types than your entities, your best option is to use @DatabaseView . A database view can be understood as a virtual table, which can be queried like a real table. A database view in floor is defined and used similarly to entities, with the main difference being that access is read-only, which means that update, insert and delete functions are not possible. Similarly to entities, the class name is used if no viewName was set. @DatabaseView ( 'SELECT distinct(name) AS name FROM person' , viewName: 'name' ) class Name { final String name ; Name ( this . name ); } Database views do not have any foreign/primary keys or indices. Instead, you should manually define indices which fit to your statement and put them into the @Entity annotation of the involved entities. Setters, getters and static fields are automatically ignored (like in entities), you can specify additional fields to ignore by annotating them with @ignore . After defining a database view in your code, you have to add it to your database by adding it to the views field of the @Database annotation: @Database ( version: 1 , entities: [ Person ], views: [ Name ]) abstract class AppDatabase extends FloorDatabase { // DAO getters } You can then query the view via a DAO function like an entity. It is possible for DatabaseViews to inherit common fields from a base class, just like in entities. Attention It is now possible to return a Stream object from a DAO method which queries a database view. But it will fire on any @update , @insert , @delete events in the whole database, which can get quite taxing on the runtime. Please add it only if you know what you are doing! This is mostly due to the complexity of detecting which entities are involved in a database view.","title":"Database Views"},{"location":"entities/","text":"Entities \u00b6 An entity is a persistent class. Floor automatically creates the mappings between the in-memory objects and database table rows. It's possible to supply custom metadata to Floor by adding optional values to the Entity annotation. It has the additional attribute of tableName which opens up the possibility to use a custom name for that specific entity instead of using the class name. foreignKeys allows adding foreign keys to the entity. More information on how to use these can be found in the Foreign Keys section. Indices are supported as well. They can be used by adding an Index to the indices value of the entity. For further information of these, please refer to the Indices section. @PrimaryKey marks property of a class as the primary key column. This property has to be of type int. The value can be automatically generated by SQLite when autoGenerate is enabled. For more information about primary keys and especially compound primary keys, refer to the Primary Keys section. @ColumnInfo enables custom mapping of single table columns. With the annotation it's possible to give columns a custom name. If you want a table's column to be nullable, mark the entity's field as nullable. More information can be found in the Null Safety section. Attention Floor automatically uses the first constructor defined in the entity class for creating in-memory objects from database rows. There needs to be a constructor. @Entity ( tableName: 'person' ) class Person { @PrimaryKey ( autoGenerate: true ) final int id ; @ColumnInfo ( name: 'custom_name' ) final String name ; Person ( this . id , this . name ); } Supported Types \u00b6 Floor entities can hold values of the following Dart types which map to their corresponding SQLite types and vice versa. int - INTEGER double - REAL String - TEXT bool - INTEGER (0 = false, 1 = true) Uint8List - BLOB In case you want to store sophisticated Dart objects that can be represented by one of the above types, take a look at Type Converters . Primary Keys \u00b6 Whenever a compound primary key is required (e.g. n-m relationships), the syntax for setting the keys differs from the previously mentioned way of setting primary keys. Instead of annotating a field with @PrimaryKey , the @Entity annotation's primaryKey attribute is used. It accepts a list of column names that make up the compound primary key. @Entity ( primaryKeys: [ 'id' , 'name' ]) class Person { final int id ; final String name ; Person ( this . id , this . name ); } Foreign Keys \u00b6 Add a list of ForeignKey s to the Entity annotation of the referencing entity. childColumns define the columns of the current entity, whereas parentColumns define the columns of the parent entity. Foreign key actions can get triggered after defining them for the onUpdate and onDelete properties. @Entity ( tableName: 'dog' , foreignKeys: [ ForeignKey ( childColumns: [ 'owner_id' ], parentColumns: [ 'id' ], entity: Person , ) ], ) class Dog { @PrimaryKey () final int id ; final String name ; @ColumnInfo ( name: 'owner_id' ) final int ownerId ; Dog ( this . id , this . name , this . ownerId ); } Indices \u00b6 Indices help speeding up query, join and grouping operations. For more information on SQLite indices please refer to the official documentation . To create an index with floor, add a list of indices to the @Entity annotation. The example below shows how to create an index on the custom_name column of the entity. The index, moreover, can be named by using its name attribute. To set an index to be unique, use the unique attribute. @Entity ( tableName: 'person' , indices: [ Index ( value: [ 'custom_name' ])]) class Person { @primaryKey final int id ; @ColumnInfo ( name: 'custom_name' ) final String name ; Person ( this . id , this . name ); } Ignoring Fields \u00b6 Getters, setters and all static fields of entities are ignored by default and thus excluded from the library's mapping. In case further fields should be ignored, the @ignore annotation should be used and applied as shown in the following snippet. class Person { @primaryKey final int id ; final String name ; @ignore String nickname ; // ignored by default String get combinedName => \" $ name ( $ nickname )\" ; Person ( this . id , this . name ); } Inheritance \u00b6 Just like Daos, entities (and database views) can inherit from a common base class and use their fields. The entity just has to extend the base class. This construct will be treated as if all the fields in the base class are part of the entity, meaning the database table will have all columns of the entity and the base class. The base class does not have to have a separate annotation for the class. Its fields can be annotated just like normal entity columns. Foreign keys and indices have to be declared in the entity and can't be defined in the base class. class BaseObject { @PrimaryKey () final int id ; @ColumnInfo ( name: 'create_time' ) final String createTime ; @ColumnInfo ( name: 'update_time' ) final String updateTime ; BaseObject ( this . id , this . updateTime , { String createTime , }) : this . createTime = createTime ?? DateTime . now (). toString (); @override List < Object > get props => []; } @Entity ( tableName: 'comments' ) class Comment extends BaseObject { final String author ; final String content ; Comment ( this . author , { int id , this . content = '' , String createTime , String updateTime , }) : super ( id , updateTime , createTime: createTime ); }","title":"Entities"},{"location":"entities/#entities","text":"An entity is a persistent class. Floor automatically creates the mappings between the in-memory objects and database table rows. It's possible to supply custom metadata to Floor by adding optional values to the Entity annotation. It has the additional attribute of tableName which opens up the possibility to use a custom name for that specific entity instead of using the class name. foreignKeys allows adding foreign keys to the entity. More information on how to use these can be found in the Foreign Keys section. Indices are supported as well. They can be used by adding an Index to the indices value of the entity. For further information of these, please refer to the Indices section. @PrimaryKey marks property of a class as the primary key column. This property has to be of type int. The value can be automatically generated by SQLite when autoGenerate is enabled. For more information about primary keys and especially compound primary keys, refer to the Primary Keys section. @ColumnInfo enables custom mapping of single table columns. With the annotation it's possible to give columns a custom name. If you want a table's column to be nullable, mark the entity's field as nullable. More information can be found in the Null Safety section. Attention Floor automatically uses the first constructor defined in the entity class for creating in-memory objects from database rows. There needs to be a constructor. @Entity ( tableName: 'person' ) class Person { @PrimaryKey ( autoGenerate: true ) final int id ; @ColumnInfo ( name: 'custom_name' ) final String name ; Person ( this . id , this . name ); }","title":"Entities"},{"location":"entities/#supported-types","text":"Floor entities can hold values of the following Dart types which map to their corresponding SQLite types and vice versa. int - INTEGER double - REAL String - TEXT bool - INTEGER (0 = false, 1 = true) Uint8List - BLOB In case you want to store sophisticated Dart objects that can be represented by one of the above types, take a look at Type Converters .","title":"Supported Types"},{"location":"entities/#primary-keys","text":"Whenever a compound primary key is required (e.g. n-m relationships), the syntax for setting the keys differs from the previously mentioned way of setting primary keys. Instead of annotating a field with @PrimaryKey , the @Entity annotation's primaryKey attribute is used. It accepts a list of column names that make up the compound primary key. @Entity ( primaryKeys: [ 'id' , 'name' ]) class Person { final int id ; final String name ; Person ( this . id , this . name ); }","title":"Primary Keys"},{"location":"entities/#foreign-keys","text":"Add a list of ForeignKey s to the Entity annotation of the referencing entity. childColumns define the columns of the current entity, whereas parentColumns define the columns of the parent entity. Foreign key actions can get triggered after defining them for the onUpdate and onDelete properties. @Entity ( tableName: 'dog' , foreignKeys: [ ForeignKey ( childColumns: [ 'owner_id' ], parentColumns: [ 'id' ], entity: Person , ) ], ) class Dog { @PrimaryKey () final int id ; final String name ; @ColumnInfo ( name: 'owner_id' ) final int ownerId ; Dog ( this . id , this . name , this . ownerId ); }","title":"Foreign Keys"},{"location":"entities/#indices","text":"Indices help speeding up query, join and grouping operations. For more information on SQLite indices please refer to the official documentation . To create an index with floor, add a list of indices to the @Entity annotation. The example below shows how to create an index on the custom_name column of the entity. The index, moreover, can be named by using its name attribute. To set an index to be unique, use the unique attribute. @Entity ( tableName: 'person' , indices: [ Index ( value: [ 'custom_name' ])]) class Person { @primaryKey final int id ; @ColumnInfo ( name: 'custom_name' ) final String name ; Person ( this . id , this . name ); }","title":"Indices"},{"location":"entities/#ignoring-fields","text":"Getters, setters and all static fields of entities are ignored by default and thus excluded from the library's mapping. In case further fields should be ignored, the @ignore annotation should be used and applied as shown in the following snippet. class Person { @primaryKey final int id ; final String name ; @ignore String nickname ; // ignored by default String get combinedName => \" $ name ( $ nickname )\" ; Person ( this . id , this . name ); }","title":"Ignoring Fields"},{"location":"entities/#inheritance","text":"Just like Daos, entities (and database views) can inherit from a common base class and use their fields. The entity just has to extend the base class. This construct will be treated as if all the fields in the base class are part of the entity, meaning the database table will have all columns of the entity and the base class. The base class does not have to have a separate annotation for the class. Its fields can be annotated just like normal entity columns. Foreign keys and indices have to be declared in the entity and can't be defined in the base class. class BaseObject { @PrimaryKey () final int id ; @ColumnInfo ( name: 'create_time' ) final String createTime ; @ColumnInfo ( name: 'update_time' ) final String updateTime ; BaseObject ( this . id , this . updateTime , { String createTime , }) : this . createTime = createTime ?? DateTime . now (). toString (); @override List < Object > get props => []; } @Entity ( tableName: 'comments' ) class Comment extends BaseObject { final String author ; final String content ; Comment ( this . author , { int id , this . content = '' , String createTime , String updateTime , }) : super ( id , updateTime , createTime: createTime ); }","title":"Inheritance"},{"location":"examples/","text":"Examples \u00b6 For further examples take a look at the example and test directories.","title":"Examples"},{"location":"examples/#examples","text":"For further examples take a look at the example and test directories.","title":"Examples"},{"location":"feedback/","text":"Bugs, Ideas, and Feedback \u00b6 For bugs please use GitHub Issues . For questions, ideas, and discussions use GitHub Discussions . For general communication use floor's Slack .","title":"Feedback"},{"location":"feedback/#bugs-ideas-and-feedback","text":"For bugs please use GitHub Issues . For questions, ideas, and discussions use GitHub Discussions . For general communication use floor's Slack .","title":"Bugs, Ideas, and Feedback"},{"location":"getting-started/","text":"Getting Started \u00b6 1. Setup Dependencies \u00b6 Add the runtime dependency floor as well as the generator floor_generator to your pubspec.yaml . The third dependency is build_runner which has to be included as a dev dependency just like the generator. floor holds all the code you are going to use in your application. floor_generator includes the code for generating the database classes. build_runner enables a concrete way of generating source code files. dependencies : flutter : sdk : flutter floor : ^1.2.0 dev_dependencies : floor_generator : ^1.2.0 build_runner : ^2.1.2 2. Create an Entity \u00b6 It will represent a database table as well as the scaffold of your business object. @entity marks the class as a persistent class. It's required to add a primary key to your table. You can do so by adding the @primaryKey annotation to an int property. There is no restriction on where you put the file containing the entity. // entity/person.dart import 'package:floor/floor.dart' ; @entity class Person { @primaryKey final int id ; final String name ; Person ( this . id , this . name ); } 3. Create a DAO (Data Access Object) \u00b6 This component is responsible for managing access to the underlying SQLite database. The abstract class contains the method signatures for querying the database which have to return a Future or Stream . You can define queries by adding the @Query annotation to a method. The SQL statement has to get added in parenthesis. The method must return a Future or Stream of the Entity you're querying for. @insert marks a method as an insertion method. // dao/person_dao.dart import 'package:floor/floor.dart' ; @dao abstract class PersonDao { @Query ( 'SELECT * FROM Person' ) Future < List < Person >> findAllPersons (); @Query ( 'SELECT * FROM Person WHERE id = :id' ) Stream < Person ?> findPersonById ( int id ); @insert Future < void > insertPerson ( Person person ); } 4. Create the Database \u00b6 It has to be an abstract class which extends FloorDatabase . Furthermore, it's required to add @Database() to the signature of the class. Make sure to add the created entity to the entities attribute of the @Database annotation. In order to make the generated code work, it's required to also add the listed imports. Make sure to add part 'database.g.dart'; beneath the imports of this file. It's important to note that 'database' has to get exchanged with the filename of the database definition. In this case, the file is named database.dart . // database.dart // required package imports import 'dart:async' ; import 'package:floor/floor.dart' ; import 'package:sqflite/sqflite.dart' as sqflite ; import 'dao/person_dao.dart' ; import 'entity/person.dart' ; part 'database.g.dart' ; // the generated code will be there @Database ( version: 1 , entities: [ Person ]) abstract class AppDatabase extends FloorDatabase { PersonDao get personDao ; } 5. Run the Code Generator \u00b6 Run the generator with flutter packages pub run build_runner build . To automatically run it, whenever a file changes, use flutter packages pub run build_runner watch . 6. Use the Generated Code \u00b6 For obtaining an instance of the database, use the generated $FloorAppDatabase class, which allows access to a database builder. The name is being composed by $Floor and the database class name. The string passed to databaseBuilder() will be the database file name. For initializing the database, call build() and make sure to await the result. In order to retrieve the PersonDao instance, invoking the persoDao getter on the database instance is enough. Its functions can be used as shown in the following snippet. final database = await $FloorAppDatabase . databaseBuilder ( 'app_database.db' ). build (); final personDao = database . personDao ; final person = Person ( 1 , 'Frank' ); await personDao . insertPerson ( person ); final result = await personDao . findPersonById ( 1 ); For further examples take a look at the example and test directories.","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#1-setup-dependencies","text":"Add the runtime dependency floor as well as the generator floor_generator to your pubspec.yaml . The third dependency is build_runner which has to be included as a dev dependency just like the generator. floor holds all the code you are going to use in your application. floor_generator includes the code for generating the database classes. build_runner enables a concrete way of generating source code files. dependencies : flutter : sdk : flutter floor : ^1.2.0 dev_dependencies : floor_generator : ^1.2.0 build_runner : ^2.1.2","title":"1. Setup Dependencies"},{"location":"getting-started/#2-create-an-entity","text":"It will represent a database table as well as the scaffold of your business object. @entity marks the class as a persistent class. It's required to add a primary key to your table. You can do so by adding the @primaryKey annotation to an int property. There is no restriction on where you put the file containing the entity. // entity/person.dart import 'package:floor/floor.dart' ; @entity class Person { @primaryKey final int id ; final String name ; Person ( this . id , this . name ); }","title":"2. Create an Entity"},{"location":"getting-started/#3-create-a-dao-data-access-object","text":"This component is responsible for managing access to the underlying SQLite database. The abstract class contains the method signatures for querying the database which have to return a Future or Stream . You can define queries by adding the @Query annotation to a method. The SQL statement has to get added in parenthesis. The method must return a Future or Stream of the Entity you're querying for. @insert marks a method as an insertion method. // dao/person_dao.dart import 'package:floor/floor.dart' ; @dao abstract class PersonDao { @Query ( 'SELECT * FROM Person' ) Future < List < Person >> findAllPersons (); @Query ( 'SELECT * FROM Person WHERE id = :id' ) Stream < Person ?> findPersonById ( int id ); @insert Future < void > insertPerson ( Person person ); }","title":"3. Create a DAO (Data Access Object)"},{"location":"getting-started/#4-create-the-database","text":"It has to be an abstract class which extends FloorDatabase . Furthermore, it's required to add @Database() to the signature of the class. Make sure to add the created entity to the entities attribute of the @Database annotation. In order to make the generated code work, it's required to also add the listed imports. Make sure to add part 'database.g.dart'; beneath the imports of this file. It's important to note that 'database' has to get exchanged with the filename of the database definition. In this case, the file is named database.dart . // database.dart // required package imports import 'dart:async' ; import 'package:floor/floor.dart' ; import 'package:sqflite/sqflite.dart' as sqflite ; import 'dao/person_dao.dart' ; import 'entity/person.dart' ; part 'database.g.dart' ; // the generated code will be there @Database ( version: 1 , entities: [ Person ]) abstract class AppDatabase extends FloorDatabase { PersonDao get personDao ; }","title":"4. Create the Database"},{"location":"getting-started/#5-run-the-code-generator","text":"Run the generator with flutter packages pub run build_runner build . To automatically run it, whenever a file changes, use flutter packages pub run build_runner watch .","title":"5. Run the Code Generator"},{"location":"getting-started/#6-use-the-generated-code","text":"For obtaining an instance of the database, use the generated $FloorAppDatabase class, which allows access to a database builder. The name is being composed by $Floor and the database class name. The string passed to databaseBuilder() will be the database file name. For initializing the database, call build() and make sure to await the result. In order to retrieve the PersonDao instance, invoking the persoDao getter on the database instance is enough. Its functions can be used as shown in the following snippet. final database = await $FloorAppDatabase . databaseBuilder ( 'app_database.db' ). build (); final personDao = database . personDao ; final person = Person ( 1 , 'Frank' ); await personDao . insertPerson ( person ); final result = await personDao . findPersonById ( 1 ); For further examples take a look at the example and test directories.","title":"6. Use the Generated Code"},{"location":"in-memory-database/","text":"In Memory Database \u00b6 To instantiate an in-memory database, use the static inMemoryDatabaseBuilder() method of the generated $FloorAppDatabase class instead of databaseBuilder() . final database = await $FloorAppDatabase . inMemoryDatabaseBuilder (). build ();","title":"In Memory Database"},{"location":"in-memory-database/#in-memory-database","text":"To instantiate an in-memory database, use the static inMemoryDatabaseBuilder() method of the generated $FloorAppDatabase class instead of databaseBuilder() . final database = await $FloorAppDatabase . inMemoryDatabaseBuilder (). build ();","title":"In Memory Database"},{"location":"initialization-callback/","text":"Initialization Callback \u00b6 In order to hook into Floor's database initialization process, Callback should be used. It allows the invocation of three separate callbacks which are triggered when the database has been initialized for the first time ( onCreate ). opened ( onOpen ). upgraded ( onUpgrade ). Each callback is optional. Their usage can be seen in the following snippet. final callback = Callback ( onCreate: ( database , version ) { /* database has been created */ }, onOpen: ( database ) { /* database has been opened */ }, onUpgrade: ( database , startVersion , endVersion ) { /* database has been upgraded */ }, ); final database = await $FloorAppDatabase . databaseBuilder ( 'app_database.db' ) . addCallback ( callback ) . build ();","title":"Initialization Callback"},{"location":"initialization-callback/#initialization-callback","text":"In order to hook into Floor's database initialization process, Callback should be used. It allows the invocation of three separate callbacks which are triggered when the database has been initialized for the first time ( onCreate ). opened ( onOpen ). upgraded ( onUpgrade ). Each callback is optional. Their usage can be seen in the following snippet. final callback = Callback ( onCreate: ( database , version ) { /* database has been created */ }, onOpen: ( database ) { /* database has been opened */ }, onUpgrade: ( database , startVersion , endVersion ) { /* database has been upgraded */ }, ); final database = await $FloorAppDatabase . databaseBuilder ( 'app_database.db' ) . addCallback ( callback ) . build ();","title":"Initialization Callback"},{"location":"isolates/","text":"Isolates \u00b6 As floor is based on sqflite, Android and iOS apps access the SQLite database on a native background thread. On Linux, macOS, and Windows, a separate isolate is used. You can do some further reading on sqflite's background work mechanisms here .","title":"Isolates"},{"location":"isolates/#isolates","text":"As floor is based on sqflite, Android and iOS apps access the SQLite database on a native background thread. On Linux, macOS, and Windows, a separate isolate is used. You can do some further reading on sqflite's background work mechanisms here .","title":"Isolates"},{"location":"migrations/","text":"Migrations \u00b6 Whenever you are doing changes to your entities, you're required to also migrate the old data. First, update your entity. Next, Increase the database version. Define a Migration which specifies a startVersion , an endVersion and a function that executes SQL to migrate the data. At last, use addMigrations() on the obtained database builder to add migrations. Don't forget to trigger the code generator again, to create the code for handling the new entity. // update entity with new 'nickname' field @Entity ( tableName: 'person' ) class Person { @PrimaryKey ( autoGenerate: true ) final int id ; @ColumnInfo ( name: 'custom_name' ) final String name ; final String nickname ; Person ( this . id , this . name , this . nickname ); } // bump up database version @Database ( version: 2 ) abstract class AppDatabase extends FloorDatabase { PersonDao get personDao ; } // create migration final migration1to2 = Migration ( 1 , 2 , ( database ) async { await database . execute ( 'ALTER TABLE person ADD COLUMN nickname TEXT' ); }); final database = await $FloorAppDatabase . databaseBuilder ( 'app_database.db' ) . addMigrations ([ migration1to2 ]) . build ();","title":"Migrations"},{"location":"migrations/#migrations","text":"Whenever you are doing changes to your entities, you're required to also migrate the old data. First, update your entity. Next, Increase the database version. Define a Migration which specifies a startVersion , an endVersion and a function that executes SQL to migrate the data. At last, use addMigrations() on the obtained database builder to add migrations. Don't forget to trigger the code generator again, to create the code for handling the new entity. // update entity with new 'nickname' field @Entity ( tableName: 'person' ) class Person { @PrimaryKey ( autoGenerate: true ) final int id ; @ColumnInfo ( name: 'custom_name' ) final String name ; final String nickname ; Person ( this . id , this . name , this . nickname ); } // bump up database version @Database ( version: 2 ) abstract class AppDatabase extends FloorDatabase { PersonDao get personDao ; } // create migration final migration1to2 = Migration ( 1 , 2 , ( database ) async { await database . execute ( 'ALTER TABLE person ADD COLUMN nickname TEXT' ); }); final database = await $FloorAppDatabase . databaseBuilder ( 'app_database.db' ) . addMigrations ([ migration1to2 ]) . build ();","title":"Migrations"},{"location":"naming/","text":"Naming \u00b6 The library's name derives from the following. Floor as the bottom layer of a Room which points to the analogy of the database layer being the bottom and foundation layer of most applications. Where fl also gives a pointer that the library is used in the Flutter context.","title":"Naming"},{"location":"naming/#naming","text":"The library's name derives from the following. Floor as the bottom layer of a Room which points to the analogy of the database layer being the bottom and foundation layer of most applications. Where fl also gives a pointer that the library is used in the Flutter context.","title":"Naming"},{"location":"null-safety/","text":"Null Safety \u00b6 Floor infers nullability of database columns directly from entity fields, as mentioned in the Entities section. When not explicitly making a field nullable by applying ? to its type, a column cannot hold NULL . For more information regarding null s as query results, see the Queries and Streams section.","title":"Null Safety"},{"location":"null-safety/#null-safety","text":"Floor infers nullability of database columns directly from entity fields, as mentioned in the Entities section. When not explicitly making a field nullable by applying ? to its type, a column cannot hold NULL . For more information regarding null s as query results, see the Queries and Streams section.","title":"Null Safety"},{"location":"platform-support/","text":"Platform Support \u00b6 Floor supports iOS, Android, Linux, macOS and Windows. The SQLite database access on iOS and Android is provided by sqflite whereas Linux, macOS and Windows use sqflite's ffi implementation. There currently is no support for Flutter for web.","title":"Platform Support"},{"location":"platform-support/#platform-support","text":"Floor supports iOS, Android, Linux, macOS and Windows. The SQLite database access on iOS and Android is provided by sqflite whereas Linux, macOS and Windows use sqflite's ffi implementation. There currently is no support for Flutter for web.","title":"Platform Support"},{"location":"testing/","text":"Testing \u00b6 Simply instantiate an in-memory database and run the database tests on your local development machine as shown in the following snippet. For more test references, check out the project's tests . In case you're running Linux, make sure to have sqlite3 and libsqlite3-dev installed. import 'package:floor/floor.dart' ; import 'package:flutter_test/flutter_test.dart' ; // your imports follow here import 'dao/person_dao.dart' ; import 'database.dart' ; import 'entity/person.dart' ; void main () { group ( 'database tests' , () { late TestDatabase database ; late PersonDao personDao ; setUp (() async { database = await $FloorTestDatabase . inMemoryDatabaseBuilder () . build (); personDao = database . personDao ; }); tearDown (() async { await database . close (); }); test ( 'find person by id' , () async { final person = Person ( 1 , 'Simon' ); await personDao . insertPerson ( person ); final actual = await personDao . findPersonById ( person . id ); expect ( actual , equals ( person )); }); } }","title":"Testing"},{"location":"testing/#testing","text":"Simply instantiate an in-memory database and run the database tests on your local development machine as shown in the following snippet. For more test references, check out the project's tests . In case you're running Linux, make sure to have sqlite3 and libsqlite3-dev installed. import 'package:floor/floor.dart' ; import 'package:flutter_test/flutter_test.dart' ; // your imports follow here import 'dao/person_dao.dart' ; import 'database.dart' ; import 'entity/person.dart' ; void main () { group ( 'database tests' , () { late TestDatabase database ; late PersonDao personDao ; setUp (() async { database = await $FloorTestDatabase . inMemoryDatabaseBuilder () . build (); personDao = database . personDao ; }); tearDown (() async { await database . close (); }); test ( 'find person by id' , () async { final person = Person ( 1 , 'Simon' ); await personDao . insertPerson ( person ); final actual = await personDao . findPersonById ( person . id ); expect ( actual , equals ( person )); }); } }","title":"Testing"},{"location":"type-converters/","text":"Type Converters \u00b6 Attention This feature is still in an experimental state. Please use it with caution and file issues for problems you encounter. SQLite allows storing values of only a handful types. Whenever more complex Dart in-memory objects should be stored, there sometimes is the need for converting between Dart and SQLite compatible types. Dart's DateTime , for instance, provides an object-oriented API for handling time. Objects of this class can simply be represented as int values by mapping DateTime to its timestamp in milliseconds. Instead of manually mapping between these types repeatedly, when reading and writing, type converters can be used. It's sufficient to define the conversion from a database to an in-memory type and vice versa once, which then is reused automatically. The implementation and usage of the mentioned DateTime to int converter is described in the following. Create a converter class that implements the abstract TypeConverter and supply the in-memory object type and database type as parameterized types. This class inherits the decode() and encode() functions which define the conversion from one to the other type. class DateTimeConverter extends TypeConverter < DateTime , int > { @override DateTime decode ( int databaseValue ) { return DateTime . fromMillisecondsSinceEpoch ( databaseValue ); } @override int encode ( DateTime value ) { return value . millisecondsSinceEpoch ; } } Apply the created type converter to the database by using the @TypeConverters annotation and make sure to additionally import the file of your type converter here. Importing it in your database file is always necessary because the generated code will be part of your database file and this is the location where your type converters get instantiated. @TypeConverters ([ DateTimeConverter ]) @Database ( version: 1 , entities: [ Order ]) abstract class OrderDatabase extends FloorDatabase { OrderDao get orderDao ; } Use the non-default DateTime type in an entity. @entity class Order { @primaryKey final int id ; final DateTime date ; Order ( this . id , this . date ); } Type converters can be applied to databases DAOs entities/views entity/view fields DAO methods DAO method parameters The type converter is added to the scope of the element so if you put it on a class, all methods/fields in that class will be able to use the converter. The closest type converter wins! If you, for example, add a converter on the database level and another one on a DAO method parameter, which takes care of converting the same types, the one declared next to the DAO method parameter will be used. Please refer to the above list to get more information about the precedence of converters.","title":"Type Converters"},{"location":"type-converters/#type-converters","text":"Attention This feature is still in an experimental state. Please use it with caution and file issues for problems you encounter. SQLite allows storing values of only a handful types. Whenever more complex Dart in-memory objects should be stored, there sometimes is the need for converting between Dart and SQLite compatible types. Dart's DateTime , for instance, provides an object-oriented API for handling time. Objects of this class can simply be represented as int values by mapping DateTime to its timestamp in milliseconds. Instead of manually mapping between these types repeatedly, when reading and writing, type converters can be used. It's sufficient to define the conversion from a database to an in-memory type and vice versa once, which then is reused automatically. The implementation and usage of the mentioned DateTime to int converter is described in the following. Create a converter class that implements the abstract TypeConverter and supply the in-memory object type and database type as parameterized types. This class inherits the decode() and encode() functions which define the conversion from one to the other type. class DateTimeConverter extends TypeConverter < DateTime , int > { @override DateTime decode ( int databaseValue ) { return DateTime . fromMillisecondsSinceEpoch ( databaseValue ); } @override int encode ( DateTime value ) { return value . millisecondsSinceEpoch ; } } Apply the created type converter to the database by using the @TypeConverters annotation and make sure to additionally import the file of your type converter here. Importing it in your database file is always necessary because the generated code will be part of your database file and this is the location where your type converters get instantiated. @TypeConverters ([ DateTimeConverter ]) @Database ( version: 1 , entities: [ Order ]) abstract class OrderDatabase extends FloorDatabase { OrderDao get orderDao ; } Use the non-default DateTime type in an entity. @entity class Order { @primaryKey final int id ; final DateTime date ; Order ( this . id , this . date ); } Type converters can be applied to databases DAOs entities/views entity/view fields DAO methods DAO method parameters The type converter is added to the scope of the element so if you put it on a class, all methods/fields in that class will be able to use the converter. The closest type converter wins! If you, for example, add a converter on the database level and another one on a DAO method parameter, which takes care of converting the same types, the one declared next to the DAO method parameter will be used. Please refer to the above list to get more information about the precedence of converters.","title":"Type Converters"}]}